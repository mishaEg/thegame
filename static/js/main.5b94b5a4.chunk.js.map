{"version":3,"sources":["functional/utils/getRandomInt.js","functional/createObject.js","functional/createMap.js","functional/initMap.js","Components/NotificationHeader.jsx","Units/Hero.js","functional/utils/isContact.js","functional/enemiesAction.js","Units/Enemy.js","functional/utils/getTopItem.js","functional/moveHero.js","functional/expansionMap.js","functional/drawTunnel.js","functional/drawCave.js","functional/movingAndDigging.js","functional/digging.js","functional/heroActions.js","functional/pickUp.js","Components/GamesMap.jsx","functional/utils/getRandomCoordinates.js","functional/drawMap.jsx","Components/App.jsx","index.js"],"names":["getRandomInt","min","max","Math","floor","random","createObject","inputMap","countOfObjects","object","elements","counter","x","length","y","len","icon","push","createMap","map","wall","emptySpace","currentRow","currentColumn","initMap","startMap","sword","shield","grass","NotificationHeader","heroStats","hero","_this","props","concat","health","weapon","name","money","message","this","react_default","a","createElement","className","Component","Hero","Object","classCallCheck","positionX","positionY","damage","defence","countOfPoison","readyToMine","isContact","target_one","target_two","enemiesAction","creatures","forEach","creature","status","regeneration","allCreatures","dx","currentDy","index","reducedDamage","matrixForPF","indexRow","indexCol","iconLastItem","hereEnemy","currentCreature","createMatrixForPF","finder","PF","AStarFinder","grid","Grid","path","findPath","move","onceEnemyAction","Enemy","depthOfSleep","stamina","type","checkTemper","irritation","rage","humility","Error","dead","wakedUp","newPositionX","newPositionY","tired","fallAsleep","getTopItem","moveHero","key","dy","wasAfight","xTravelCoordinates","yTravelCoordinates","ectoplasma","upperItem","arrayCreatures","_heroHitsCreature","isDied","getDamage","enemyStatusBefore","fightMessage","heroHitsCreature","splice","changeCoordinates","expansionMap","targetCoordinate","replacement","replacementItems","checkCoordinateY","checkCoordinateX","undefined","_loop","newAddedLine","unshift","currentEnemy","currentReplace","drawTunnel","diggingCoordinate","generateGem","gem","drawCave","direction","treasure","iron_sword","iron_shield","drawBodyCave","movingAndDigging","RANDOM_GENERATE_ITEM","digging","heroActions","gex","pop","currentShield","dropShield","takeShield","currentWeapon","dropWeapon","takeWeapon","eat","pickUp","effectsHandler","GamesMap","possibleConstructorReturn","getPrototypeOf","call","componentWillMount","createdMap","coordinates","coordinateX","coordinateY","findItemWithFloor","getRandomCoordinates","enemy","state","setState","componentWillReceiveProps","nextProps","keyPress","handleKeyPressed","_this$state","onHelp","_this$state2","drawingMap","generatedMap","currentCreatures","rowIndex","colIndex","drawMap","NotificationHeader_NotificationHeader","App","_this2","acceptKeys","react_keyboard_event_handler_default","handleKeys","onKeyEvent","GamesMap_GamesMap","ReactDOM","render","App_App","document","getElementById"],"mappings":"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","file":"static/js/main.5b94b5a4.chunk.js","sourcesContent":["// Возвращает случайное целое число между min (включительно) и max (включительно)\nexport default function getRandomInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n","import elements from '../data/elements';\nimport getRandomInt from './utils/getRandomInt';\n\n/**\n * @description Функция для случайной генерации на карте там, где уже расположен пол\n * @param {Array} inputMap - Входящий двухмерный массив\n * @param {Number} countOfObjects - Количество, необходимых сгенерировать на карте\n */\nexport default function createObject(inputMap, countOfObjects, object) {\n    const { floor } = elements;\n\n    for (let counter = 0; counter < countOfObjects; counter++) {\n        const x = getRandomInt(2, inputMap[0].length - 1),\n            y = getRandomInt(2, inputMap.length - 1),\n            len = inputMap[y][x].length - 1;\n\n        if (inputMap[y][x][len].icon === floor.icon) {\n            inputMap[y][x].push(object);\n        } else {\n            counter--;\n        }\n    }\n}\n","import createObject from './createObject';\nimport initMap from './initMap';\nimport startMap from '../data/map.json';\nimport { sword, shield, grass } from '../data/elements';\n\nexport default function createMap() {\n    const map = initMap(startMap);\n\n    createObject(map, 1, sword);\n    createObject(map, 1, shield);\n    createObject(map, 2, grass);\n\n    return map;\n}\n","import elements from '../data/elements';\n\n/**\n * @description Функция для преобразования входящего массива в массив объектов\n * @param {Array} map - Двумерный массив из спецсимволов\n * @return {Array} Возвращает трехмерный массив объектов\n */\nexport default function initMap(map) {\n    const { floor, wall, emptySpace } = elements;\n\n    return map.map(currentRow => currentRow.map((currentColumn) => {\n        switch (currentColumn) {\n            case '=': return [wall];\n            case '*': return [floor];\n            default: return [emptySpace];\n        }\n    }));\n}\n","import React, { Component } from 'react';\n\nexport default class NotificationHeader extends Component {\n    heroStats = () => {\n        const { hero } = this.props;\n        if (hero) {\n            const message = `health: ${hero.health} | weapon: ${hero.weapon.name} | shield: ${hero.shield.name} | money: ${hero.money}`;\n            return message;\n        }\n        return null;\n    }\n\n    render() {\n        const { message } = this.props;\n\n        return (\n            <div className=\"message_bar\">\n                {this.heroStats()}\n                <br />\n                {message}\n            </div>\n        );\n    }\n}\n","export default class Hero {\n    constructor(y, x) {\n        this.positionX = x;\n        this.positionY = y;\n        this.icon = 'hero';\n        this.health = 100;\n        this.damage = 2;\n        this.defence = 0;\n        this.money = 0;\n        this.weapon = {\n            name: 'none'\n        };\n        this.shield = {\n            name: 'none'\n        };\n        this.countOfPoison = 0;\n        this.readyToMine = false;\n    }\n\n    effectsHandler() {\n        if (this.countOfPoison > 0) {\n            this.health -= this.countOfPoison;\n        }\n    }\n\n    eat() {\n        this.health += 100;\n        this.countOfPoison += 1;\n    }\n\n    takeWeapon(weapon) {\n        this.weapon = weapon;\n        this.damage += weapon.damage;\n    }\n\n    dropWeapon() {\n        this.damage -= this.weapon.damage;\n        this.weapon = {\n            name: 'none'\n        };\n    }\n\n    takeShield(shield) {\n        this.shield = shield;\n        this.defence += shield.defence;\n    }\n\n    dropShield() {\n        this.defence -= this.shield.defence;\n        this.shield = {\n            name: 'none'\n        };\n    }\n\n    changeCoordinates(x, y) {\n        this.positionX = x;\n        this.positionY = y;\n    }\n}\n","/**\n * @description Проверка совпадения координат 2 объектов\n * @return {Boolean} true - если объекты находятся в 1 ячейке\n */\nexport default function isContact(target_one, target_two) {\n    return target_one.positionX === target_two.positionX && target_one.positionY === target_two.positionY;\n}\n","import PF from 'pathfinding';\nimport isContact from './utils/isContact';\n\nfunction createMatrixForPF(map, allCreatures) {\n    const matrixForPF = map.map((currentRow, indexRow) => {\n        return currentRow.map((currentColumn, indexCol) => {\n            const iconLastItem = currentColumn[currentColumn.length - 1].icon;\n            let hereEnemy = false;\n\n            allCreatures.forEach((currentCreature) => {\n                if (currentCreature.positionY === indexRow && currentCreature.positionX === indexCol) {\n                    hereEnemy = true;\n                }\n            });\n            if (iconLastItem === 'wall' || hereEnemy) {\n                return 1;\n            }\n            return 0;\n        });\n    });\n\n    return matrixForPF;\n}\n\n\n/**\n * @description реализация функции передвижения переданного врага\n */\nfunction onceEnemyAction(creature, map, hero, allCreatures) {\n    const dy = [+0, +1, -1, 0, 1, -1, 0, 1, -1], // смещения, для обхвата площади\n        dx = [-1, -1, -1, 0, 0, +0, 1, 1, +1]; // размером 3х3 с центром в указанной точке\n\n    dy.forEach((currentDy, index) => {\n        const XpositionForCheckHero = creature.positionX + dx[index],\n            YpositionForCheckHero = creature.positionY + currentDy;\n\n        if (isContact({ positionX: XpositionForCheckHero, positionY: YpositionForCheckHero }, hero)) {\n            const reducedDamage = creature.damage - hero.defence;\n            if (reducedDamage > 0) {\n                hero.health -= reducedDamage;\n            }\n        }\n    });\n\n    const matrixForPF = createMatrixForPF(map, allCreatures),\n        finder = new PF.AStarFinder(),\n        grid = new PF.Grid(matrixForPF),\n        path = finder.findPath(creature.positionX, creature.positionY, hero.positionX, hero.positionY, grid);\n\n    // Если путь не найден, массив будет пустым\n    // Если путь найден и следующий шаг будет не на позицию героя, тогда монстр двигается\n    if (path.length !== 0 && !(path[1][0] === hero.positionX && path[1][1] === hero.positionY)) {\n        creature.move(path[1][0], path[1][1]);\n    }\n}\n\n/**\n * Реализация действий всех существ на карте\n */\nfunction enemiesAction(hero, map, creatures) {\n    creatures.forEach((creature) => {\n        if (creature.status === 'sleeping') {\n            creature.regeneration();\n        } else {\n            onceEnemyAction(creature, map, hero, creatures);\n        }\n    });\n}\n\nexport default enemiesAction;\n","export default class Enemy {\n    constructor(positionX, positionY) {\n        this.positionX = positionX;\n        this.positionY = positionY;\n        this.icon = 'sleeping_enemy';\n        this.health = 100;\n        this.depthOfSleep = 2;\n        this.stamina = 0;\n        this.damage = 50;\n        this.status = 'sleeping';\n        this.type = 'enemy';\n    }\n\n    wakedUp() {\n        this.status = 'awake';\n        this.icon = 'awaken_enemy';\n        this.stamina = 20;\n        this.depthOfSleep = 0;\n    }\n\n    fallAsleep() {\n        this.status = 'sleeping';\n        this.icon = 'sleeping_enemy';\n        this.depthOfSleep = 2;\n    }\n\n    regeneration() {\n        if (this.health < 100 && this.health > 0) {\n            this.health += 1;\n            this.checkTemper();\n        }\n    }\n\n    checkTemper() {\n        if (this.status !== 'sleeping') {\n            switch (true) {\n                case (this.health >= 50 && this.health < 90):\n                    this.irritation();\n                    break;\n                case (this.health >= 20 && this.health < 50):\n                    this.rage();\n                    break;\n                case (this.health < 20):\n                    this.humility();\n                    break;\n                default: break;\n            }\n        }\n    }\n\n    getDamage(damage) {\n        if (+damage) {\n            this.health = this.health - damage;\n            if (this.health <= 0) {\n                this.dead();\n                return;\n            }\n            if (this.depthOfSleep === 1) {\n                this.wakedUp();\n            }\n            this.checkTemper();\n            if (this.depthOfSleep !== 0) {\n                this.depthOfSleep -= 1;\n            }\n        } else {\n            throw new Error('damage is not a number');\n        }\n    }\n\n    irritation() {\n        this.status = 'irritation';\n        this.damage = 60;\n        this.stamina = 30;\n    }\n\n    rage() {\n        this.status = 'rage';\n        this.damage = 100;\n        this.stamina = 40;\n    }\n\n    humility() {\n        this.status = 'humility';\n        this.damage = 10;\n        this.stamina = 6;\n    }\n\n    changePosition(newPositionX, newPositionY) {\n        this.positionX = newPositionX;\n        this.positionY = newPositionY;\n    }\n\n    move(newPositionX, newPositionY) {\n        this.positionX = newPositionX;\n        this.positionY = newPositionY;\n        this.tired();\n    }\n\n    dead() {\n        this.status = 'dead';\n    }\n\n    tired() {\n        if (this.stamina > 0) {\n            this.stamina -= 2;\n        } else if (this.stamina === 0) {\n            this.fallAsleep();\n        }\n    }\n}\n","/**\n * @description функция поиска самого верхнего элемента по заданным координатам\n * @return последний элемент массива в заданной ячейке карты\n */\nfunction getTopItem(map, y, x) {\n    const len = map[y][x].length;\n\n    return map[y][x][len - 1];\n}\n\nexport default getTopItem;\n","import getTopItem from './utils/getTopItem';\nimport isContact from './utils/isContact';\nimport elements from '../data/elements';\n\n/**\n * Реализация сражения героя с монстром\n */\nfunction heroHitsCreature(hero, creature) {\n    let message = 'you punch enemy',\n        isDied = false;\n\n    if (creature.status === 'sleeping') {\n        if (creature.depthOfSleep === 2) {\n            message = \"you punch sleeping enemy, once more punch for waked up\";\n        } else if (creature.depthOfSleep === 1) {\n            message = \"you punch sleeping enemy and woke him up\";\n        }\n        creature.getDamage(hero.damage);\n    } else {\n        const enemyStatusBefore = creature.status;\n\n        creature.getDamage(hero.damage);\n        if (enemyStatusBefore !== creature.status) {\n            switch (creature.status) {\n                case 'irritation':\n                    message = 'you punch enemy and he became irritated';\n                    break;\n                case 'rage':\n                    message = 'you punch enemy and he became raged';\n                    break;\n                case 'humility':\n                    message = 'you punch enemy and he became humble';\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n\n    if (creature.status === 'dead') {\n        message = 'you punch enemy and kill him';\n        isDied = true;\n    }\n\n    return {\n        isDied: isDied,\n        fightMessage: message\n    };\n}\n\n/**\n * Реализация функции движения героя на карте\n * @return message - лог событий или false\n */\nfunction moveHero(map, hero, key, creatures) {\n    let dx = 0,\n        dy = 0,\n        message = false,\n        wasAfight = false;\n\n    switch (key) {\n        case \"left\": dx = -1; break;\n        case \"right\": dx = 1; break;\n        case \"up\": dy = -1; break;\n        case \"down\": dy = 1; break;\n        default: throw new Error(\"key is not correct:\" + key);\n    }\n\n    const xTravelCoordinates = hero.positionX + dx,\n        yTravelCoordinates = hero.positionY + dy,\n        { ectoplasma } = elements,\n        upperItem = getTopItem(map, yTravelCoordinates, xTravelCoordinates);\n\n    creatures.forEach((currentCreature, index, arrayCreatures) => {\n        if (isContact({ positionX: xTravelCoordinates, positionY: yTravelCoordinates }, currentCreature)) {\n            const {\n                fightMessage,\n                isDied\n            } = heroHitsCreature(hero, currentCreature);\n\n            wasAfight = true;\n            message = fightMessage;\n            if (isDied) {\n                map[yTravelCoordinates][xTravelCoordinates].push(ectoplasma);\n                arrayCreatures.splice(index, 1); // Удаляем текущее существо из массива, если оно умерло\n            }\n        }\n    });\n\n    if (!wasAfight) {\n        switch (upperItem.icon) {\n            case 'wall':\n                message = 'there is no the way';\n                break;\n            case ' ':\n                message = 'Its whitespace? how did you do this?? (bug!)';\n                break;\n            case 'grass':\n                message = 'you stay at grass and feels fresh green leaves by your feet :з.';\n                hero.changeCoordinates(xTravelCoordinates, yTravelCoordinates);\n                break;\n            default: {\n                if (upperItem.type) {\n                    message = 'you stay at ' + upperItem.name + ', if you wanna pick it up, press \"p\"';\n                }\n                hero.changeCoordinates(xTravelCoordinates, yTravelCoordinates);\n            }\n        }\n    }\n\n    return message;\n}\n\nexport default moveHero;\n","import elements from '../data/elements';\n\n/**\n * Реализация возможности увеличения карты с возможной заменой массива элементов на переданный\n *\n * @param {Object} targetCoordinate - координаты точки для смещений\n * @param {Array} dx - массив смещений для координаты x\n * @param {Array} dy - массив смещений для координаты y\n * @param {Array} map - трехмерный массив объектов карты, которую необходимо увеличить\n * @param {Object} hero - объект героя, координаты которого необходимо менять в зависсимости от расширения\n * @param {Object} replacement - объект, который необходимо сгенерировать на всех координатах смещения\n * @param {Array} creatures - массив объектов врага, координаты которых необходимо менять при расширении карты\n */\nfunction expansionMap(targetCoordinate, dx, dy, map, hero, replacement, replacementItems, creatures) {\n    const { emptySpace } = elements;\n\n    dy.forEach((currentDy, index) => {\n        let checkCoordinateY = targetCoordinate.y + currentDy,\n            checkCoordinateX = targetCoordinate.x + dx[index];\n\n        if (map[checkCoordinateY] === undefined) {\n            while (checkCoordinateY < 0 || checkCoordinateY > map.length - 1) {\n                const newAddedLine = [];\n\n                map[hero.positionY].forEach(() => {\n                    newAddedLine.push([emptySpace]);\n                });\n                newAddedLine[checkCoordinateX] = [replacement];\n                if (checkCoordinateY < 0) { // добавление новой линии к карте сверху\n                    map.unshift(newAddedLine); // добавление в начало массива map значения newAddedLine\n                    hero.positionY += 1;\n                    targetCoordinate.y += 1;\n                    checkCoordinateY += 1;\n                    creatures.forEach((currentEnemy) => {\n                        currentEnemy.positionY += 1;\n                    });\n                } else if (checkCoordinateY > map.length - 1) { // добавление линии снизу\n                    map.push(newAddedLine);\n                }\n            }\n        } else if (map[checkCoordinateY][checkCoordinateX] === undefined) {\n            while (checkCoordinateX < 0 || checkCoordinateX > map[checkCoordinateY].length - 1) {\n                if (checkCoordinateX < 0) { // добавление новой клетки к карте слева\n                    map.forEach((currentRow) => {\n                        currentRow.unshift([emptySpace]); // добавление в начало каждой строки элемента\n                    });\n                    creatures.forEach((currentEnemy) => {\n                        currentEnemy.positionX += 1;\n                    });\n                    map[checkCoordinateY][0][0] = replacement;\n                    hero.positionX += 1;\n                    targetCoordinate.x += 1;\n                    checkCoordinateX += 1;\n                } else { // добавление столбца к карте справа\n                    map.forEach((currentRow) => {\n                        currentRow.push([emptySpace]);\n                    });\n                }\n            }\n            map[checkCoordinateY][checkCoordinateX][0] = replacement;\n        } else {\n            replacementItems.forEach((currentReplace) => {\n                if (map[checkCoordinateY][checkCoordinateX][0].icon === currentReplace.icon) {\n                    map[checkCoordinateY][checkCoordinateX][0] = replacement;\n                }\n            });\n        }\n    });\n}\n\nexport default expansionMap;\n","import elements from '../data/elements';\nimport expansionMap from './expansionMap';\nimport getRandomInt from './utils/getRandomInt';\n\n/**\n * Реализация генерации входа в пещеру на карте\n */\nfunction drawTunnel(diggingCoordinate, generateGem, map, hero, creatures) {\n    const { floor, emptySpace, wall, gem } = elements,\n        dx = [-1, -1, -1, 0, 0, +0, 1, 1, +1], // смещения, для обхвата площади\n        dy = [+0, +1, -1, 0, 1, -1, 0, 1, -1]; // размером 3х3 с центром в указанной точке\n\n    // Генерация стен вокруг указанной точки\n    expansionMap(diggingCoordinate, dx, dy, map, hero, wall, [emptySpace], creatures);\n    // Замена стены в указанной точке на пол\n    expansionMap(diggingCoordinate, [0], [0], map, hero, floor, [wall], creatures);\n\n    let message = false;\n    if (generateGem) {\n        const RANDOM_GENERATE_GEM = getRandomInt(0, 9);\n\n        if (RANDOM_GENERATE_GEM === 0) {\n            map[diggingCoordinate.y][diggingCoordinate.x].push(gem);\n            message = 'you found a gem!';\n        }\n    }\n\n    return message;\n}\n\nexport default drawTunnel;\n","import elements from '../data/elements';\nimport expansionMap from './expansionMap';\nimport Enemy from '../Units/Enemy';\nimport drawTunnel from './drawTunnel';\n\n/**\n * Реализация генерации пещеры с сокровищем на карте\n */\nfunction drawBodyCave(diggingCoordinate, treasure, map, hero, creatures) {\n    const { floor, emptySpace, wall, grass, iron_sword, iron_shield } = elements,\n        dx = [-1, -1, -1, 0, 0, +0, 1, 1, +1], // смещения, для обхвата площади\n        dy = [+0, +1, -1, 0, 1, -1, 0, 1, -1], // размером 3х3 с центром в указанной точке\n        wall_dx = [-1, 0, 1, -2, 2, -2, 2, -2, 2, -2, +2, -2, -1, +0, +1, +2], // смещения для отрисовки\n        wall_dy = [+2, 2, 2, +2, 2, +1, 1, +0, 0, -1, -1, -2, -2, -2, -2, -2]; // стен во всех пещерах\n\n    // Генерация пола пещеры размером 3х3 с центром в указанной точке\n    expansionMap(diggingCoordinate, dx, dy, map, hero, floor, [emptySpace, wall], creatures);\n\n    // Генерация стен вокруг пещеры с центром в указанной точке\n    expansionMap(diggingCoordinate, wall_dx, wall_dy, map, hero, wall, [emptySpace], creatures);\n\n\n    switch (treasure) {\n        case 'enemy':\n            creatures.push(new Enemy(diggingCoordinate.x, diggingCoordinate.y));\n            break;\n        case 'grass':\n            map[diggingCoordinate.y][diggingCoordinate.x].push(grass);\n            break;\n        case 'iron sword':\n            map[diggingCoordinate.y][diggingCoordinate.x].push(iron_sword);\n            break;\n        case 'iron shield':\n            map[diggingCoordinate.y][diggingCoordinate.x].push(iron_shield);\n            break;\n        case 'none':\n            break;\n        default:\n            throw new Error(`Treasure is not correct: ${treasure}`);\n    }\n}\n\n/**\n * @description реализация генерации пещеры на карте\n * @return generateEnemy false - если пещера сгенерирована без врага, object - враг\n */\nfunction drawCave(diggingCoordinate, direction, treasure, map, hero, creatures) {\n    drawTunnel(diggingCoordinate, false, map, hero, creatures);\n\n    switch (direction) {\n        case 'left':\n            diggingCoordinate.x -= 2;\n            break;\n        case 'right':\n            diggingCoordinate.x += 2;\n            break;\n        case 'up':\n            diggingCoordinate.y -= 2;\n            break;\n        case 'down':\n            diggingCoordinate.y += 2;\n            break;\n        default:\n            throw new Error(\"direction is not a correct:\" + direction);\n    }\n    drawBodyCave(diggingCoordinate, treasure, map, hero, creatures);\n}\n\nexport default drawCave;\n","import moveHero from './moveHero';\nimport digging from './digging';\n\nfunction movingAndDigging(map, hero, key, creatures) {\n    let loggingMessage;\n\n    if (hero.readyToMine) {\n        loggingMessage = digging(map, hero, key, creatures);\n    } else {\n        loggingMessage = moveHero(map, hero, key, creatures);\n    }\n\n    return loggingMessage;\n}\n\nexport default movingAndDigging;\n","import getRandomInt from './utils/getRandomInt';\nimport getTopItem from './utils/getTopItem';\nimport drawCave from './drawCave';\nimport drawTunnel from './drawTunnel';\n\n/**\n * Реализация функции копания для героя\n * @return message\n */\nexport default function digging(map, hero, direction, creatures) {\n    let dx = 0,\n        dy = 0,\n        message = \"there is nothing to dig\";\n\n    hero.readyToMine = false;\n\n    switch (direction) {\n        case \"left\": dx = -1; break;\n        case \"right\": dx = 1; break;\n        case \"up\": dy = -1; break;\n        case \"down\": dy = 1; break;\n        default: throw new Error(\"Некорректный параметр direction:\" + direction);\n    }\n\n    const diggingCoordinate = {\n            x: hero.positionX + dx,\n            y: hero.positionY + dy\n        },\n        diggingItem = getTopItem(map, diggingCoordinate.y, diggingCoordinate.x);\n\n    if (diggingItem.icon !== 'wall') {\n        return message;\n    }\n\n    const RANDOM_GENERATE_CAVE = getRandomInt(0, 4);\n\n    if (RANDOM_GENERATE_CAVE === 0) { // Условие для генерации пещеры, шанс 20%\n        const RANDOM_GENERATE_ITEM = getRandomInt(0, 7);\n        let treasure = '';\n\n        switch (true) {\n            case (RANDOM_GENERATE_ITEM === 2 || RANDOM_GENERATE_ITEM === 3):\n                message = 'you found cave with enemy!';\n                treasure = 'enemy';\n                break;\n            case (RANDOM_GENERATE_ITEM === 4 || RANDOM_GENERATE_ITEM === 5):\n                message = 'you found cave with grass!';\n                treasure = 'grass';\n                break;\n            case (RANDOM_GENERATE_ITEM === 6):\n                message = 'you found cave with iron shield!';\n                treasure = 'iron shield';\n                break;\n            case (RANDOM_GENERATE_ITEM === 7):\n                message = 'you found cave with iron sword!';\n                treasure = 'iron sword';\n                break;\n            default:\n                message = 'you found empty cave';\n                treasure = 'none';\n        }\n\n        drawCave(diggingCoordinate, direction, treasure, map, hero, creatures);\n    } else {\n        // Если рандом на пещеру не выпал, тогда отрисовываем\n        // туннель с вероятностью раскопки камня 10%\n        message = drawTunnel(diggingCoordinate, true, map, hero, creatures);\n    }\n\n    return message;\n}\n","import movingAndDigging from './movingAndDigging';\nimport pickUp from './pickUp';\n\nexport default function heroActions(hero, map, creatures, key) {\n    let message;\n\n    switch (key) {\n        case 'p':\n            message = pickUp(map, hero);\n            break;\n        case 'd':\n            if (hero.weapon.name !== 'none') {\n                hero.readyToMine = !hero.readyToMine;\n                if (hero.readyToMine) {\n                    message = `you rised the pickaxe (${hero.weapon.name}). Now, choose direction to dig`;\n                } else {\n                    message = `you lower the pickaxe (${hero.weapon.name})`;\n                }\n            } else {\n                message = 'you need any weapon to dig';\n            }\n            break;\n        default: {\n            message = movingAndDigging(map, hero, key, creatures);\n        }\n    }\n    hero.effectsHandler();\n\n    return message;\n}\n","import getTopItem from './utils/getTopItem';\n\n/**\n * @description Функция реализации поднятия героем предметов\n */\nexport default function pickUp(map, hero) {\n    const gex = getTopItem(map, hero.positionY, hero.positionX);\n    let message;\n\n    switch (gex.type) {\n        case 'money':\n            hero.money += 10;\n            map[hero.positionY][hero.positionX].pop(); // удаляем на карте предмет, который подняли\n            message = 'you raised money and take 10 gold! ^_^';\n            break;\n        case 'shield':\n            if (hero.shield.name !== 'none') {\n                const currentShield = hero.shield;\n\n                hero.dropShield();\n                hero.takeShield(gex);\n                map[hero.positionY][hero.positionX].pop(); // удаляем на карте предмет, который подняли\n                map[hero.positionY][hero.positionX].push(currentShield);\n            } else {\n                hero.takeShield(gex);\n                map[hero.positionY][hero.positionX].pop(); // удаляем на карте предмет, который подняли\n            }\n            message = 'you raised ' + gex.name + '!';\n            break;\n        case 'weapon':\n            if (hero.weapon.name !== 'none') {\n                const currentWeapon = hero.weapon;\n\n                hero.dropWeapon();\n                hero.takeWeapon(gex);\n                map[hero.positionY][hero.positionX].pop(); // удаляем на карте предмет, который подняли\n                map[hero.positionY][hero.positionX].push(currentWeapon);\n            } else {\n                hero.takeWeapon(gex);\n                map[hero.positionY][hero.positionX].pop(); // удаляем на карте предмет, который подняли\n            }\n            message = 'you raised ' + gex.name + '!';\n            break;\n        case 'food':\n            hero.eat();\n            map[hero.positionY][hero.positionX].pop(); // удаляем на карте предмет, который подняли\n            message = 'you picked up and eat ' + gex.name + ', but feel bad';\n            break;\n        default:\n            message = 'no items to take';\n    }\n    return message;\n}\n","import React, { Component } from 'react';\nimport drawMap from '../functional/drawMap';\nimport createMap from '../functional/createMap';\nimport getRandomCoordinates from '../functional/utils/getRandomCoordinates';\nimport NotificationHeader from './NotificationHeader';\nimport Hero from '../Units/Hero';\nimport enemiesAction from '../functional/enemiesAction';\nimport Enemy from '../Units/Enemy';\nimport heroActions from '../functional/heroActions';\n\nexport default class GamesMap extends Component {\n    constructor() {\n        super();\n        this.state = {\n            onHelp: false,\n            message: '',\n            hero: new Hero(2, 2),\n            creatures: []\n        };\n    }\n\n    componentWillMount = () => {\n        const createdMap = createMap(),\n            coordinates = getRandomCoordinates(createdMap),\n            enemy = new Enemy(coordinates.x, coordinates.y),\n            { creatures } = this.state;\n\n        creatures.push(enemy);\n        this.setState({\n            map: createdMap,\n            creatures: creatures\n        });\n    }\n\n    componentWillReceiveProps = (nextProps) => {\n        const { keyPress } = nextProps;\n\n        if (keyPress !== null) {\n            this.handleKeyPressed(keyPress);\n        }\n    }\n\n    handleKeyPressed = (key) => {\n        const { map, hero, creatures, onHelp } = this.state;\n\n        if (key === 'h') {\n            this.setState({\n                onHelp: !onHelp\n            });\n\n            return;\n        }\n\n        const message = heroActions(hero, map, creatures, key);\n\n        enemiesAction(hero, map, creatures);\n        this.setState({\n            hero: hero,\n            map: map,\n            message: message,\n            creatures: creatures\n        });\n    };\n\n    render() {\n        const { map, hero, message, creatures, onHelp } = this.state;\n        let drawingMap = [];\n\n        if (map) {\n            drawingMap = drawMap(map, hero, creatures);\n        }\n\n        return (\n            <div>\n                {onHelp\n                    ? (\n                        <div>\n                            <h1>||HELP||</h1>\n                            <h3>1. for moving use arrow keys</h3>\n                            <h3>2. for digging use \"d\" key. Works only if you have any weapon</h3>\n                            <h3>3. for close help menu press \"h\" key again</h3>\n                        </div>\n                    )\n                    : (\n                        <div>\n                            <NotificationHeader\n                                hero={hero}\n                                message={message}\n                            />\n                            <table>\n                                <tbody>\n                                    {drawingMap}\n                                </tbody>\n                            </table>\n                        </div>\n                    )\n                }\n            </div>\n        );\n    }\n}\n","import elements from '../../data/elements';\nimport getRandomInt from './getRandomInt';\n\n// Тут отсутствуют проверки на существование пола на карте по текущим координатам.\n// Есть интересная возможность зациклиться всему приложению в этом месте.\nexport default function getRandomCoordinates(map) {\n    const { floor } = elements;\n    let findItemWithFloor = false,\n        coordinateX,\n        coordinateY;\n\n    while (!findItemWithFloor) {\n        coordinateX = getRandomInt(2, map[0].length - 1);\n        coordinateY = getRandomInt(2, map.length - 1);\n\n        const len = map[coordinateY][coordinateX].length - 1;\n\n        if (map[coordinateY][coordinateX][len].icon === floor.icon) {\n            findItemWithFloor = true;\n        }\n    }\n\n    return {\n        x: coordinateX,\n        y: coordinateY\n    };\n}\n","import React from 'react';\n\n/**\n * @description Функция для преобразования карты в формат для отрисовки\n * @param {Array} inputMap - Входящий двухмерный массив\n * @return {Array} - Возвращает новый массив для отрисовки\n */\nexport default function drawMap(inputMap, hero, creatures) {\n    const generatedMap = inputMap.map(currentRow => (\n        currentRow.map(currentColumn => (\n            currentColumn[currentColumn.length - 1].icon\n        ))\n    ));\n\n    generatedMap[hero.positionY][hero.positionX] = hero.icon;\n\n    creatures.forEach((currentCreatures) => {\n        generatedMap[currentCreatures.positionY][currentCreatures.positionX] = currentCreatures.icon;\n    });\n\n    return generatedMap.map((currentRow, rowIndex) => (\n        <tr key={rowIndex}>\n            {currentRow.map((currentColumn, colIndex) => (\n                <td key={colIndex}>\n                    <div className={`map_object ${currentColumn}`} />\n                </td>\n            ))}\n        </tr>\n    ));\n}\n","import KeyboardEventHandler from 'react-keyboard-event-handler';\nimport React, { Component } from 'react';\nimport GamesMap from './GamesMap';\n\nexport default class App extends Component {\n    constructor() {\n        super();\n        this.state = {\n            keyPress: null\n        };\n    }\n\n    handleKeyPressed = (key) => {\n        this.setState({\n            keyPress: key\n        });\n    }\n\n    render() {\n        let acceptKeys = ['down', 'left', 'right', 'up', 'h', 'p', 'd'];\n        const { onHelp, keyPress } = this.state;\n\n        if (onHelp) {\n            acceptKeys = ['h'];\n        }\n\n        return (\n            <div>\n                <KeyboardEventHandler\n                    handleKeys={acceptKeys}\n                    onKeyEvent={key => this.handleKeyPressed(key)}\n                />\n                <GamesMap keyPress={keyPress} />\n            </div>\n        );\n    }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './Components/App';\nimport './tiles/styles.css';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}