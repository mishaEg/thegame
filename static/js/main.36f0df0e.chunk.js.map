{"version":3,"sources":["functional/utils/getRandomInt.js","functional/createObject.js","functional/createMap.js","functional/initMap.js","Components/NotificationHeader.jsx","Units/Hero.js","functional/utils/isContact.js","functional/enemiesAction.js","Units/Enemy.js","functional/utils/getTopItem.js","functional/moveHero.js","functional/expansionMap.js","functional/drawTunnel.js","functional/drawCave.js","functional/movingAndDigging.js","functional/digging.js","functional/heroActions.js","functional/pickUp.js","Components/GamesMap.jsx","functional/utils/getRandomCoordinates.js","functional/drawMap.jsx","Components/App.jsx","index.js"],"names":["getRandomInt","min","max","Math","floor","random","createObject","inputMap","countOfObjects","object","elements","counter","x","length","y","len","icon","push","createMap","map","wall","emptySpace","currentRow","currentColumn","initMap","startMap","sword","shield","grass","NotificationHeader","heroStats","hero","_this","props","concat","health","weapon","name","money","message","this","react_default","a","createElement","className","Component","Hero","Object","classCallCheck","positionX","positionY","damage","defence","countOfPoison","readyToMine","isContact","target_one","target_two","enemiesAction","creatures","forEach","creature","status","regeneration","allCreatures","dx","currentDy","index","matrixForPF","indexRow","indexCol","iconLastItem","hereEnemy","currentCreature","createMatrixForPF","finder","PF","AStarFinder","grid","Grid","path","findPath","move","onceEnemyAction","Enemy","depthOfSleep","stamina","type","checkTemper","irritation","rage","humility","Error","dead","wakedUp","newPositionX","newPositionY","tired","fallAsleep","getTopItem","moveHero","key","dy","wasAfight","xTravelCoordinates","yTravelCoordinates","ectoplasma","upperItem","arrayCreatures","_heroHitsCreature","isDied","getDamage","enemyStatusBefore","fightMessage","heroHitsCreature","splice","changeCoordinates","expansionMap","targetCoordinate","replacement","replacementItems","checkCoordinateY","checkCoordinateX","undefined","_loop","newAddedLine","unshift","currentEnemy","currentReplace","drawTunnel","diggingCoordinate","generateGem","gem","drawCave","direction","treasure","iron_sword","iron_shield","drawBodyCave","movingAndDigging","RANDOM_GENERATE_ITEM","digging","heroActions","gex","pop","takeShield","takeWeapon","eat","pickUp","effectsHandler","GamesMap","possibleConstructorReturn","getPrototypeOf","call","componentWillMount","createdMap","coordinates","coordinateX","coordinateY","findItemWithFloor","getRandomCoordinates","enemy","state","setState","componentWillReceiveProps","nextProps","keyPress","handleKeyPressed","_this$state","onHelp","_this$state2","drawingMap","generatedMap","currentCreatures","rowIndex","colIndex","drawMap","NotificationHeader_NotificationHeader","App","_this2","acceptKeys","react_keyboard_event_handler_default","handleKeys","onKeyEvent","GamesMap_GamesMap","ReactDOM","render","App_App","document","getElementById"],"mappings":"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","file":"static/js/main.36f0df0e.chunk.js","sourcesContent":["// Возвращает случайное целое число между min (включительно) и max (включительно)\r\nexport default function getRandomInt(min, max) {\r\n    return Math.floor(Math.random() * (max - min + 1)) + min;\r\n}\r\n","import elements from '../data/elements';\r\nimport getRandomInt from './utils/getRandomInt';\r\n\r\n/**\r\n * @description Функция для случайной генерации на карте там, где уже расположен пол\r\n * @param {Array} inputMap - Входящий двухмерный массив\r\n * @param {Number} countOfObjects - Количество, необходимых сгенерировать на карте\r\n */\r\nexport default function createObject(inputMap, countOfObjects, object) {\r\n    const { floor } = elements;\r\n\r\n    for (let counter = 0; counter < countOfObjects; counter++) {\r\n        const x = getRandomInt(2, inputMap[0].length - 1),\r\n            y = getRandomInt(2, inputMap.length - 1),\r\n            len = inputMap[y][x].length - 1;\r\n\r\n        if (inputMap[y][x][len].icon === floor.icon) {\r\n            inputMap[y][x].push(object);\r\n        } else {\r\n            counter--;\r\n        }\r\n    }\r\n}\r\n","import createObject from './createObject';\r\nimport initMap from './initMap';\r\nimport startMap from '../data/map.json';\r\nimport { sword, shield, grass } from '../data/elements';\r\n\r\nexport default function createMap() {\r\n    const map = initMap(startMap);\r\n\r\n    createObject(map, 1, sword);\r\n    createObject(map, 1, shield);\r\n    createObject(map, 2, grass);\r\n\r\n    return map;\r\n}\r\n","import elements from '../data/elements';\r\n\r\n/**\r\n * @description Функция для преобразования входящего массива в массив объектов\r\n * @param {Array} map - Двумерный массив из спецсимволов\r\n * @return {Array} Возвращает трехмерный массив объектов\r\n */\r\nexport default function initMap(map) {\r\n    const { floor, wall, emptySpace } = elements;\r\n\r\n    return map.map(currentRow => currentRow.map((currentColumn) => {\r\n        switch (currentColumn) {\r\n            case '=': return [wall];\r\n            case '*': return [floor];\r\n            default: return [emptySpace];\r\n        }\r\n    }));\r\n}\r\n","import React, { Component } from 'react';\r\n\r\nexport default class NotificationHeader extends Component {\r\n    heroStats = () => {\r\n        const { hero } = this.props;\r\n        if (hero) {\r\n            const message = `health: ${hero.health} | weapon: ${hero.weapon.name} | shield: ${hero.shield.name} | money: ${hero.money}`;\r\n            return message;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    render() {\r\n        const { message } = this.props;\r\n\r\n        return (\r\n            <div className=\"message_bar\">\r\n                {this.heroStats()}\r\n                <br />\r\n                {message}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","export default class Hero {\r\n    constructor(y, x) {\r\n        this.positionX = x;\r\n        this.positionY = y;\r\n        this.icon = 'hero';\r\n        this.health = 100;\r\n        this.damage = 2;\r\n        this.defence = 0;\r\n        this.money = 0;\r\n        this.weapon = {\r\n            name: 'none'\r\n        };\r\n        this.shield = {\r\n            name: 'none'\r\n        };\r\n        this.countOfPoison = 0;\r\n        this.readyToMine = false;\r\n    }\r\n\r\n    effectsHandler() {\r\n        if (this.countOfPoison > 0) {\r\n            this.health -= this.countOfPoison;\r\n        }\r\n    }\r\n\r\n    eat() {\r\n        this.health += 100;\r\n        this.countOfPoison += 1;\r\n    }\r\n\r\n    takeWeapon(weapon) {\r\n        this.weapon = weapon;\r\n        this.damage += weapon.damage;\r\n    }\r\n\r\n    takeShield(shield) {\r\n        this.shield = shield;\r\n        this.defence += shield.defence;\r\n    }\r\n\r\n    changeCoordinates(x, y) {\r\n        this.positionX = x;\r\n        this.positionY = y;\r\n    }\r\n}\r\n","/**\r\n * @description Проверка совпадения координат 2 объектов\r\n * @return {Boolean} true - если объекты находятся в 1 ячейке\r\n */\r\nexport default function isContact(target_one, target_two) {\r\n    return target_one.positionX === target_two.positionX && target_one.positionY === target_two.positionY;\r\n}\r\n","import PF from 'pathfinding';\r\nimport isContact from './utils/isContact';\r\n\r\nfunction createMatrixForPF(map, allCreatures) {\r\n    const matrixForPF = map.map((currentRow, indexRow) => {\r\n        return currentRow.map((currentColumn, indexCol) => {\r\n            const iconLastItem = currentColumn[currentColumn.length - 1].icon;\r\n            let hereEnemy = false;\r\n\r\n            allCreatures.forEach((currentCreature) => {\r\n                if (currentCreature.positionY === indexRow && currentCreature.positionX === indexCol) {\r\n                    hereEnemy = true;\r\n                }\r\n            });\r\n            if (iconLastItem === 'wall' || hereEnemy) {\r\n                return 1;\r\n            }\r\n            return 0;\r\n        });\r\n    });\r\n\r\n    return matrixForPF;\r\n}\r\n\r\n\r\n/**\r\n * @description реализация функции передвижения переданного врага\r\n */\r\nfunction onceEnemyAction(creature, map, hero, allCreatures) {\r\n    const dy = [+0, +1, -1, 0, 1, -1, 0, 1, -1], // смещения, для обхвата площади\r\n        dx = [-1, -1, -1, 0, 0, +0, 1, 1, +1]; // размером 3х3 с центром в указанной точке\r\n\r\n    dy.forEach((currentDy, index) => {\r\n        const XpositionForCheckHero = creature.positionX + dx[index],\r\n            YpositionForCheckHero = creature.positionY + currentDy;\r\n\r\n        if (isContact({ positionX: XpositionForCheckHero, positionY: YpositionForCheckHero }, hero)) {\r\n            hero.health -= creature.damage;\r\n        }\r\n    });\r\n\r\n    const matrixForPF = createMatrixForPF(map, allCreatures),\r\n        finder = new PF.AStarFinder(),\r\n        grid = new PF.Grid(matrixForPF),\r\n        path = finder.findPath(creature.positionX, creature.positionY, hero.positionX, hero.positionY, grid);\r\n\r\n    // Если путь не найден, массив будет пустым\r\n    // Если путь найден и следующий шаг будет не на позицию героя, тогда монстр двигается\r\n    if (path.length !== 0 && !(path[1][0] === hero.positionX && path[1][1] === hero.positionY)) {\r\n        creature.move(path[1][0], path[1][1]);\r\n    }\r\n}\r\n\r\n/**\r\n * Реализация действий всех существ на карте\r\n */\r\nfunction enemiesAction(hero, map, creatures) {\r\n    creatures.forEach((creature) => {\r\n        if (creature.status === 'sleeping') {\r\n            creature.regeneration();\r\n        } else {\r\n            onceEnemyAction(creature, map, hero, creatures);\r\n        }\r\n    });\r\n}\r\n\r\nexport default enemiesAction;\r\n","export default class Enemy {\r\n    constructor(positionX, positionY) {\r\n        this.positionX = positionX;\r\n        this.positionY = positionY;\r\n        this.icon = 'sleeping_enemy';\r\n        this.health = 100;\r\n        this.depthOfSleep = 2;\r\n        this.stamina = 0;\r\n        this.damage = 50;\r\n        this.status = 'sleeping';\r\n        this.type = 'enemy';\r\n    }\r\n\r\n    wakedUp() {\r\n        this.status = 'awake';\r\n        this.icon = 'awaken_enemy';\r\n        this.stamina = 20;\r\n        this.depthOfSleep = 0;\r\n    }\r\n\r\n    fallAsleep() {\r\n        this.status = 'sleeping';\r\n        this.icon = 'sleeping_enemy';\r\n        this.depthOfSleep = 2;\r\n    }\r\n\r\n    regeneration() {\r\n        if (this.health < 100 && this.health > 0) {\r\n            this.health += 1;\r\n            this.checkTemper();\r\n        }\r\n    }\r\n\r\n    checkTemper() {\r\n        if (this.status !== 'sleeping') {\r\n            switch (true) {\r\n                case (this.health >= 50 && this.health < 90):\r\n                    this.irritation();\r\n                    break;\r\n                case (this.health >= 20 && this.health < 50):\r\n                    this.rage();\r\n                    break;\r\n                case (this.health < 20):\r\n                    this.humility();\r\n                    break;\r\n                default: break;\r\n            }\r\n        }\r\n    }\r\n\r\n    getDamage(damage) {\r\n        if (+damage) {\r\n            this.health = this.health - damage;\r\n            if (this.health <= 0) {\r\n                this.dead();\r\n                return;\r\n            }\r\n            if (this.depthOfSleep === 1) {\r\n                this.wakedUp();\r\n            }\r\n            this.checkTemper();\r\n            if (this.depthOfSleep !== 0) {\r\n                this.depthOfSleep -= 1;\r\n            }\r\n        } else {\r\n            throw new Error('damage is not a number');\r\n        }\r\n    }\r\n\r\n    irritation() {\r\n        this.status = 'irritation';\r\n        this.damage = 60;\r\n        this.stamina = 30;\r\n    }\r\n\r\n    rage() {\r\n        this.status = 'rage';\r\n        this.damage = 100;\r\n        this.stamina = 40;\r\n    }\r\n\r\n    humility() {\r\n        this.status = 'humility';\r\n        this.damage = 10;\r\n        this.stamina = 6;\r\n    }\r\n\r\n    changePosition(newPositionX, newPositionY) {\r\n        this.positionX = newPositionX;\r\n        this.positionY = newPositionY;\r\n    }\r\n\r\n    move(newPositionX, newPositionY) {\r\n        this.positionX = newPositionX;\r\n        this.positionY = newPositionY;\r\n        this.tired();\r\n    }\r\n\r\n    dead() {\r\n        this.status = 'dead';\r\n    }\r\n\r\n    tired() {\r\n        if (this.stamina > 0) {\r\n            this.stamina -= 2;\r\n        } else if (this.stamina === 0) {\r\n            this.fallAsleep();\r\n        }\r\n    }\r\n}\r\n","/**\r\n * @description функция поиска самого верхнего элемента по заданным координатам\r\n * @return последний элемент массива в заданной ячейке карты\r\n */\r\nfunction getTopItem(map, y, x) {\r\n    const len = map[y][x].length;\r\n\r\n    return map[y][x][len - 1];\r\n}\r\n\r\nexport default getTopItem;\r\n","import getTopItem from './utils/getTopItem';\r\nimport isContact from './utils/isContact';\r\nimport elements from '../data/elements';\r\n\r\n/**\r\n * Реализация сражения героя с монстром\r\n */\r\nfunction heroHitsCreature(hero, creature) {\r\n    let message = 'you punch enemy',\r\n        isDied = false;\r\n\r\n    if (creature.status === 'sleeping') {\r\n        if (creature.depthOfSleep === 2) {\r\n            message = \"you punch sleeping enemy, once more punch for waked up\";\r\n        } else if (creature.depthOfSleep === 1) {\r\n            message = \"you punch sleeping enemy and woke him up\";\r\n        }\r\n        creature.getDamage(hero.damage);\r\n    } else {\r\n        const enemyStatusBefore = creature.status;\r\n\r\n        creature.getDamage(hero.damage);\r\n        if (enemyStatusBefore !== creature.status) {\r\n            switch (creature.status) {\r\n                case 'irritation':\r\n                    message = 'you punch enemy and he became irritated';\r\n                    break;\r\n                case 'rage':\r\n                    message = 'you punch enemy and he became raged';\r\n                    break;\r\n                case 'humility':\r\n                    message = 'you punch enemy and he became humble';\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (creature.status === 'dead') {\r\n        message = 'you punch enemy and kill him';\r\n        isDied = true;\r\n    }\r\n\r\n    return {\r\n        isDied: isDied,\r\n        fightMessage: message\r\n    };\r\n}\r\n\r\n/**\r\n * Реализация функции движения героя на карте\r\n * @return message - лог событий или false\r\n */\r\nfunction moveHero(map, hero, key, creatures) {\r\n    let dx = 0,\r\n        dy = 0,\r\n        message = false,\r\n        wasAfight = false;\r\n\r\n    switch (key) {\r\n        case \"left\": dx = -1; break;\r\n        case \"right\": dx = 1; break;\r\n        case \"up\": dy = -1; break;\r\n        case \"down\": dy = 1; break;\r\n        default: throw new Error(\"key is not correct:\" + key);\r\n    }\r\n\r\n    const xTravelCoordinates = hero.positionX + dx,\r\n        yTravelCoordinates = hero.positionY + dy,\r\n        { ectoplasma } = elements,\r\n        upperItem = getTopItem(map, yTravelCoordinates, xTravelCoordinates);\r\n\r\n    creatures.forEach((currentCreature, index, arrayCreatures) => {\r\n        if (isContact({ positionX: xTravelCoordinates, positionY: yTravelCoordinates }, currentCreature)) {\r\n            const {\r\n                fightMessage,\r\n                isDied\r\n            } = heroHitsCreature(hero, currentCreature);\r\n\r\n            wasAfight = true;\r\n            message = fightMessage;\r\n            if (isDied) {\r\n                map[yTravelCoordinates][xTravelCoordinates].push(ectoplasma);\r\n                arrayCreatures.splice(index, 1); // Удаляем текущее существо из массива, если оно умерло\r\n            }\r\n        }\r\n    });\r\n\r\n    if (!wasAfight) {\r\n        switch (upperItem.icon) {\r\n            case 'wall':\r\n                message = 'there is no the way';\r\n                break;\r\n            case ' ':\r\n                message = 'Its whitespace? how did you do this?? (bug!)';\r\n                break;\r\n            case 'grass':\r\n                message = 'you stay at grass and feels fresh green leaves by your foots :з.';\r\n                hero.changeCoordinates(xTravelCoordinates, yTravelCoordinates);\r\n                break;\r\n            default: {\r\n                if (upperItem.type) {\r\n                    message = 'you stay at ' + upperItem.name + ', if you wanna pick it up, press \"p\"';\r\n                }\r\n                hero.changeCoordinates(xTravelCoordinates, yTravelCoordinates);\r\n            }\r\n        }\r\n    }\r\n\r\n    return message;\r\n}\r\n\r\nexport default moveHero;\r\n","import elements from '../data/elements';\r\n\r\n/**\r\n * Реализация возможности увеличения карты с возможной заменой массива элементов на переданный\r\n *\r\n * @param {Object} targetCoordinate - координаты точки для смещений\r\n * @param {Array} dx - массив смещений для координаты x\r\n * @param {Array} dy - массив смещений для координаты y\r\n * @param {Array} map - трехмерный массив объектов карты, которую необходимо увеличить\r\n * @param {Object} hero - объект героя, координаты которого необходимо менять в зависсимости от расширения\r\n * @param {Object} replacement - объект, который необходимо сгенерировать на всех координатах смещения\r\n * @param {Array} creatures - массив объектов врага, координаты которых необходимо менять при расширении карты\r\n */\r\nfunction expansionMap(targetCoordinate, dx, dy, map, hero, replacement, replacementItems, creatures) {\r\n    const { emptySpace } = elements;\r\n\r\n    dy.forEach((currentDy, index) => {\r\n        let checkCoordinateY = targetCoordinate.y + currentDy,\r\n            checkCoordinateX = targetCoordinate.x + dx[index];\r\n\r\n        if (map[checkCoordinateY] === undefined) {\r\n            while (checkCoordinateY < 0 || checkCoordinateY > map.length - 1) {\r\n                const newAddedLine = [];\r\n\r\n                map[hero.positionY].forEach(() => {\r\n                    newAddedLine.push([emptySpace]);\r\n                });\r\n                newAddedLine[checkCoordinateX] = [replacement];\r\n                if (checkCoordinateY < 0) { // добавление новой линии к карте сверху\r\n                    map.unshift(newAddedLine); // добавление в начало массива map значения newAddedLine\r\n                    hero.positionY += 1;\r\n                    targetCoordinate.y += 1;\r\n                    checkCoordinateY += 1;\r\n                    creatures.forEach((currentEnemy) => {\r\n                        currentEnemy.positionY += 1;\r\n                    });\r\n                } else if (checkCoordinateY > map.length - 1) { // добавление линии снизу\r\n                    map.push(newAddedLine);\r\n                }\r\n            }\r\n        } else if (map[checkCoordinateY][checkCoordinateX] === undefined) {\r\n            while (checkCoordinateX < 0 || checkCoordinateX > map[checkCoordinateY].length - 1) {\r\n                if (checkCoordinateX < 0) { // добавление новой клетки к карте слева\r\n                    map.forEach((currentRow) => {\r\n                        currentRow.unshift([emptySpace]); // добавление в начало каждой строки элемента\r\n                    });\r\n                    creatures.forEach((currentEnemy) => {\r\n                        currentEnemy.positionX += 1;\r\n                    });\r\n                    map[checkCoordinateY][0][0] = replacement;\r\n                    hero.positionX += 1;\r\n                    targetCoordinate.x += 1;\r\n                    checkCoordinateX += 1;\r\n                } else { // добавление столбца к карте справа\r\n                    map.forEach((currentRow) => {\r\n                        currentRow.push([emptySpace]);\r\n                    });\r\n                }\r\n            }\r\n            map[checkCoordinateY][checkCoordinateX][0] = replacement;\r\n        } else {\r\n            replacementItems.forEach((currentReplace) => {\r\n                if (map[checkCoordinateY][checkCoordinateX][0].icon === currentReplace.icon) {\r\n                    map[checkCoordinateY][checkCoordinateX][0] = replacement;\r\n                }\r\n            });\r\n        }\r\n    });\r\n}\r\n\r\nexport default expansionMap;\r\n","import elements from '../data/elements';\r\nimport expansionMap from './expansionMap';\r\nimport getRandomInt from './utils/getRandomInt';\r\n\r\n/**\r\n * Реализация генерации входа в пещеру на карте\r\n */\r\nfunction drawTunnel(diggingCoordinate, generateGem, map, hero, creatures) {\r\n    const { floor, emptySpace, wall, gem } = elements,\r\n        dx = [-1, -1, -1, 0, 0, +0, 1, 1, +1], // смещения, для обхвата площади\r\n        dy = [+0, +1, -1, 0, 1, -1, 0, 1, -1]; // размером 3х3 с центром в указанной точке\r\n\r\n    // Генерация стен вокруг указанной точки\r\n    expansionMap(diggingCoordinate, dx, dy, map, hero, wall, [emptySpace], creatures);\r\n    // Замена стены в указанной точке на пол\r\n    expansionMap(diggingCoordinate, [0], [0], map, hero, floor, [wall], creatures);\r\n\r\n    let message = false;\r\n    if (generateGem) {\r\n        const RANDOM_GENERATE_GEM = getRandomInt(0, 9);\r\n\r\n        if (RANDOM_GENERATE_GEM === 0) {\r\n            map[diggingCoordinate.y][diggingCoordinate.x].push(gem);\r\n            message = 'you found a gem!';\r\n        }\r\n    }\r\n\r\n    return message;\r\n}\r\n\r\nexport default drawTunnel;\r\n","import elements from '../data/elements';\r\nimport expansionMap from './expansionMap';\r\nimport Enemy from '../Units/Enemy';\r\nimport drawTunnel from './drawTunnel';\r\n\r\n/**\r\n * Реализация генерации пещеры с сокровищем на карте\r\n */\r\nfunction drawBodyCave(diggingCoordinate, treasure, map, hero, creatures) {\r\n    const { floor, emptySpace, wall, grass, iron_sword, iron_shield } = elements,\r\n        dx = [-1, -1, -1, 0, 0, +0, 1, 1, +1], // смещения, для обхвата площади\r\n        dy = [+0, +1, -1, 0, 1, -1, 0, 1, -1], // размером 3х3 с центром в указанной точке\r\n        wall_dx = [-1, 0, 1, -2, 2, -2, 2, -2, 2, -2, +2, -2, -1, +0, +1, +2], // смещения для отрисовки\r\n        wall_dy = [+2, 2, 2, +2, 2, +1, 1, +0, 0, -1, -1, -2, -2, -2, -2, -2]; // стен во всех пещерах\r\n\r\n    // Генерация пола пещеры размером 3х3 с центром в указанной точке\r\n    expansionMap(diggingCoordinate, dx, dy, map, hero, floor, [emptySpace, wall], creatures);\r\n\r\n    // Генерация стен вокруг пещеры с центром в указанной точке\r\n    expansionMap(diggingCoordinate, wall_dx, wall_dy, map, hero, wall, [emptySpace], creatures);\r\n\r\n\r\n    switch (treasure) {\r\n        case 'enemy':\r\n            creatures.push(new Enemy(diggingCoordinate.x, diggingCoordinate.y));\r\n            break;\r\n        case 'grass':\r\n            map[diggingCoordinate.y][diggingCoordinate.x].push(grass);\r\n            break;\r\n        case 'iron sword':\r\n            map[diggingCoordinate.y][diggingCoordinate.x].push(iron_sword);\r\n            break;\r\n        case 'iron shield':\r\n            map[diggingCoordinate.y][diggingCoordinate.x].push(iron_shield);\r\n            break;\r\n        case 'none':\r\n            break;\r\n        default:\r\n            throw new Error(`Treasure is not correct: ${treasure}`);\r\n    }\r\n}\r\n\r\n/**\r\n * @description реализация генерации пещеры на карте\r\n * @return generateEnemy false - если пещера сгенерирована без врага, object - враг\r\n */\r\nfunction drawCave(diggingCoordinate, direction, treasure, map, hero, creatures) {\r\n    drawTunnel(diggingCoordinate, false, map, hero, creatures);\r\n\r\n    switch (direction) {\r\n        case 'left':\r\n            diggingCoordinate.x -= 2;\r\n            break;\r\n        case 'right':\r\n            diggingCoordinate.x += 2;\r\n            break;\r\n        case 'up':\r\n            diggingCoordinate.y -= 2;\r\n            break;\r\n        case 'down':\r\n            diggingCoordinate.y += 2;\r\n            break;\r\n        default:\r\n            throw new Error(\"direction is not a correct:\" + direction);\r\n    }\r\n    drawBodyCave(diggingCoordinate, treasure, map, hero, creatures);\r\n}\r\n\r\nexport default drawCave;\r\n","import moveHero from './moveHero';\r\nimport digging from './digging';\r\n\r\nfunction movingAndDigging(map, hero, key, creatures) {\r\n    let loggingMessage;\r\n\r\n    if (hero.readyToMine) {\r\n        loggingMessage = digging(map, hero, key, creatures);\r\n    } else {\r\n        loggingMessage = moveHero(map, hero, key, creatures);\r\n    }\r\n\r\n    return loggingMessage;\r\n}\r\n\r\nexport default movingAndDigging;\r\n","import getRandomInt from './utils/getRandomInt';\r\nimport getTopItem from './utils/getTopItem';\r\nimport drawCave from './drawCave';\r\nimport drawTunnel from './drawTunnel';\r\n\r\n/**\r\n * Реализация функции копания для героя\r\n * @return message\r\n */\r\nexport default function digging(map, hero, direction, creatures) {\r\n    let dx = 0,\r\n        dy = 0,\r\n        message = \"there is nothing to dig\";\r\n\r\n    hero.readyToMine = false;\r\n\r\n    switch (direction) {\r\n        case \"left\": dx = -1; break;\r\n        case \"right\": dx = 1; break;\r\n        case \"up\": dy = -1; break;\r\n        case \"down\": dy = 1; break;\r\n        default: throw new Error(\"Некорректный параметр direction:\" + direction);\r\n    }\r\n\r\n    const diggingCoordinate = {\r\n            x: hero.positionX + dx,\r\n            y: hero.positionY + dy\r\n        },\r\n        diggingItem = getTopItem(map, diggingCoordinate.y, diggingCoordinate.x);\r\n\r\n    if (diggingItem.icon !== 'wall') {\r\n        return message;\r\n    }\r\n\r\n    const RANDOM_GENERATE_CAVE = getRandomInt(0, 4);\r\n\r\n    if (RANDOM_GENERATE_CAVE === 0) { // Условие для генерации пещеры, шанс 20%\r\n        const RANDOM_GENERATE_ITEM = getRandomInt(0, 7);\r\n        let treasure = '';\r\n\r\n        switch (true) {\r\n            case (RANDOM_GENERATE_ITEM === 2 || RANDOM_GENERATE_ITEM === 3):\r\n                message = 'you found cave with enemy!';\r\n                treasure = 'enemy';\r\n                break;\r\n            case (RANDOM_GENERATE_ITEM === 4 || RANDOM_GENERATE_ITEM === 5):\r\n                message = 'you found cave with grass!';\r\n                treasure = 'grass';\r\n                break;\r\n            case (RANDOM_GENERATE_ITEM === 6):\r\n                message = 'you found cave with iron shield!';\r\n                treasure = 'iron shield';\r\n                break;\r\n            case (RANDOM_GENERATE_ITEM === 7):\r\n                message = 'you found cave with iron sword!';\r\n                treasure = 'iron sword';\r\n                break;\r\n            default:\r\n                message = 'you found empty cave';\r\n                treasure = 'none';\r\n        }\r\n\r\n        drawCave(diggingCoordinate, direction, treasure, map, hero, creatures);\r\n    } else {\r\n        // Если рандом на пещеру не выпал, тогда отрисовываем\r\n        // туннель с вероятностью раскопки камня 10%\r\n        message = drawTunnel(diggingCoordinate, true, map, hero, creatures);\r\n    }\r\n\r\n    return message;\r\n}\r\n","import movingAndDigging from './movingAndDigging';\r\nimport pickUp from './pickUp';\r\n\r\nexport default function heroActions(hero, map, creatures, key) {\r\n    let message;\r\n\r\n    switch (key) {\r\n        case 'p':\r\n            message = pickUp(map, hero);\r\n            break;\r\n        case 'd':\r\n            if (hero.weapon.name !== 'none') {\r\n                hero.readyToMine = !hero.readyToMine;\r\n                if (hero.readyToMine) {\r\n                    message = `you rised the pickaxe (${hero.weapon.name}). Now, choose direction to dig`;\r\n                } else {\r\n                    message = `you lower the pickaxe (${hero.weapon.name})`;\r\n                }\r\n            } else {\r\n                message = 'you need any weapon to dig';\r\n            }\r\n            break;\r\n        default: {\r\n            message = movingAndDigging(map, hero, key, creatures);\r\n        }\r\n    }\r\n    hero.effectsHandler();\r\n\r\n    return message;\r\n}\r\n","import getTopItem from './utils/getTopItem';\r\n\r\n/**\r\n * @description Функция реализации поднятия героем предметов\r\n */\r\nexport default function pickUp(map, hero) {\r\n    const gex = getTopItem(map, hero.positionY, hero.positionX);\r\n    let message;\r\n\r\n    switch (gex.type) {\r\n        case 'money':\r\n            hero.money += 10;\r\n            map[hero.positionY][hero.positionX].pop(); // удаляем на карте предмет, который подняли\r\n            message = 'you raised money and take 10 gold! ^_^';\r\n            break;\r\n        case 'shield':\r\n            hero.takeShield(gex);\r\n            map[hero.positionY][hero.positionX].pop(); // удаляем на карте предмет, который подняли\r\n            message = 'you raised ' + gex.name + '!';\r\n            break;\r\n        case 'weapon':\r\n            hero.takeWeapon(gex);\r\n            map[hero.positionY][hero.positionX].pop(); // удаляем на карте предмет, который подняли\r\n            message = 'you raised ' + gex.name + ' and increace your power!';\r\n            break;\r\n        case 'food':\r\n            hero.eat();\r\n            map[hero.positionY][hero.positionX].pop(); // удаляем на карте предмет, который подняли\r\n            message = 'you picked up and eat ' + gex.name + ', but feel bad';\r\n            break;\r\n        default:\r\n            message = 'no items to take';\r\n    }\r\n    return message;\r\n}\r\n","import React, { Component } from 'react';\r\nimport drawMap from '../functional/drawMap';\r\nimport createMap from '../functional/createMap';\r\nimport getRandomCoordinates from '../functional/utils/getRandomCoordinates';\r\nimport NotificationHeader from './NotificationHeader';\r\nimport Hero from '../Units/Hero';\r\nimport enemiesAction from '../functional/enemiesAction';\r\nimport Enemy from '../Units/Enemy';\r\nimport heroActions from '../functional/heroActions';\r\n\r\nexport default class GamesMap extends Component {\r\n    constructor() {\r\n        super();\r\n        this.state = {\r\n            onHelp: false,\r\n            message: '',\r\n            hero: new Hero(2, 2),\r\n            creatures: []\r\n        };\r\n    }\r\n\r\n    componentWillMount = () => {\r\n        const createdMap = createMap(),\r\n            coordinates = getRandomCoordinates(createdMap),\r\n            enemy = new Enemy(coordinates.x, coordinates.y),\r\n            { creatures } = this.state;\r\n\r\n        creatures.push(enemy);\r\n        this.setState({\r\n            map: createdMap,\r\n            creatures: creatures\r\n        });\r\n    }\r\n\r\n    componentWillReceiveProps = (nextProps) => {\r\n        const { keyPress } = nextProps;\r\n\r\n        if (keyPress !== null) {\r\n            this.handleKeyPressed(keyPress);\r\n        }\r\n    }\r\n\r\n    handleKeyPressed = (key) => {\r\n        const { map, hero, creatures, onHelp } = this.state;\r\n\r\n        if (key === 'h') {\r\n            this.setState({\r\n                onHelp: !onHelp\r\n            });\r\n\r\n            return;\r\n        }\r\n\r\n        const message = heroActions(hero, map, creatures, key);\r\n\r\n        enemiesAction(hero, map, creatures);\r\n        this.setState({\r\n            hero: hero,\r\n            map: map,\r\n            message: message,\r\n            creatures: creatures\r\n        });\r\n    };\r\n\r\n    render() {\r\n        const { map, hero, message, creatures, onHelp } = this.state;\r\n        let drawingMap = [];\r\n\r\n        if (map) {\r\n            drawingMap = drawMap(map, hero, creatures);\r\n        }\r\n\r\n        return (\r\n            <div>\r\n                {onHelp\r\n                    ? (\r\n                        <div>\r\n                            <h1>||HELP||</h1>\r\n                            <h3>1. for moving use arrow keys</h3>\r\n                            <h3>2. for digging use \"d\" key. Works only if you have any weapon</h3>\r\n                            <h3>3. for close help menu press \"h\" key again</h3>\r\n                        </div>\r\n                    )\r\n                    : (\r\n                        <div>\r\n                            <NotificationHeader\r\n                                hero={hero}\r\n                                message={message}\r\n                            />\r\n                            <table>\r\n                                <tbody>\r\n                                    {drawingMap}\r\n                                </tbody>\r\n                            </table>\r\n                        </div>\r\n                    )\r\n                }\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","import elements from '../../data/elements';\r\nimport getRandomInt from './getRandomInt';\r\n\r\n// Тут отсутствуют проверки на существование пола на карте по текущим координатам.\r\n// Есть интересная возможность зациклиться всему приложению в этом месте.\r\nexport default function getRandomCoordinates(map) {\r\n    const { floor } = elements;\r\n    let findItemWithFloor = false,\r\n        coordinateX,\r\n        coordinateY;\r\n\r\n    while (!findItemWithFloor) {\r\n        coordinateX = getRandomInt(2, map[0].length - 1);\r\n        coordinateY = getRandomInt(2, map.length - 1);\r\n\r\n        const len = map[coordinateY][coordinateX].length - 1;\r\n\r\n        if (map[coordinateY][coordinateX][len].icon === floor.icon) {\r\n            findItemWithFloor = true;\r\n        }\r\n    }\r\n\r\n    return {\r\n        x: coordinateX,\r\n        y: coordinateY\r\n    };\r\n}\r\n","import React from 'react';\r\n\r\n/**\r\n * @description Функция для преобразования карты в формат для отрисовки\r\n * @param {Array} inputMap - Входящий двухмерный массив\r\n * @return {Array} - Возвращает новый массив для отрисовки\r\n */\r\nexport default function drawMap(inputMap, hero, creatures) {\r\n    const generatedMap = inputMap.map(currentRow => (\r\n        currentRow.map(currentColumn => (\r\n            currentColumn[currentColumn.length - 1].icon\r\n        ))\r\n    ));\r\n\r\n    generatedMap[hero.positionY][hero.positionX] = hero.icon;\r\n\r\n    creatures.forEach((currentCreatures) => {\r\n        generatedMap[currentCreatures.positionY][currentCreatures.positionX] = currentCreatures.icon;\r\n    });\r\n\r\n    return generatedMap.map((currentRow, rowIndex) => (\r\n        <tr key={rowIndex}>\r\n            {currentRow.map((currentColumn, colIndex) => (\r\n                <td key={colIndex}>\r\n                    <div className={`map_object ${currentColumn}`} />\r\n                </td>\r\n            ))}\r\n        </tr>\r\n    ));\r\n}\r\n","import KeyboardEventHandler from 'react-keyboard-event-handler';\r\nimport React, { Component } from 'react';\r\nimport GamesMap from './GamesMap';\r\n\r\nexport default class App extends Component {\r\n    constructor() {\r\n        super();\r\n        this.state = {\r\n            keyPress: null\r\n        };\r\n    }\r\n\r\n    handleKeyPressed = (key) => {\r\n        this.setState({\r\n            keyPress: key\r\n        });\r\n    }\r\n\r\n    render() {\r\n        let acceptKeys = ['down', 'left', 'right', 'up', 'h', 'p', 'd'];\r\n        const { onHelp, keyPress } = this.state;\r\n\r\n        if (onHelp) {\r\n            acceptKeys = ['h'];\r\n        }\r\n\r\n        return (\r\n            <div>\r\n                <KeyboardEventHandler\r\n                    handleKeys={acceptKeys}\r\n                    onKeyEvent={key => this.handleKeyPressed(key)}\r\n                />\r\n                <GamesMap keyPress={keyPress} />\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './Components/App';\r\nimport './tiles/styles.css';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n"],"sourceRoot":""}